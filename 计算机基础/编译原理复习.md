# 编译复习

## 一、概论

### 1. 概念

编译程序的地位：系统软件。

编译程序和解释程序的根本区别：是否生成目标代码。

源程序的执行过程：分析阶段（源语言->中间代码）、综合阶段（中间代码->目标程序）。

编译程序的六个过程：词法分析、语句分析、语义分析、代码生成、中间代码生成、代码优化。

二义性文法：一个文法的某个句子存在两棵不同的语法树，则称该文法是二义性文法。



## 二、文法和形式语言

### 1. 概念

字母表、符号、符号串、符号串集合

句子：字母表上符合某种规则的符号串。

语言：句子的集合。

文法：构造句子的规则，用于产生和推导句子。

BNF表示法：**用“|”表示“或”，用以合并左部相同的规则，规则的左部只有单个非终结符**。

### 2.推导和规约

直接推导：直接推导就是在推导过程中每次只用一个规则来进行替换。

广义推导：

最左推导：每次先替换最左边的非终结符。

最右推导：每次先替换最右边的非终结符。

规范推导：最右推导，最左规约。

句型，句子。

### 3.短语、简单短语、句柄

例子：

**E ::=E-T | T**  

**T** **::=T\*F | F**

**F** **::=(E) | i**

短语：E-F\*i、F\*i，F、i；

直接短语：F、i；

句柄：i。

### 4.文法实用限制

有害规则：

- 形如S=>S;

多余规则：

- Z=>xUy，U称为活的非终结符。

- 不可推出句子的规则：C=>Cf

### 5.文法变换

**文法的开始符号不出现在规则的右部**
**每个非终结符号均能导出终结符号串**

**每个非终结符号都出现在任意句型中**

**没有特殊规则，形如**A::=B

**没有空规则，形如**A::=**ε**
**没有直接左递归规则**

文法变换技术：

引进符号S’，在文法中拓充一条规则S’→S。

递归扩充：**找到推不出句子的非终结符，并删除多余规则**。

**消除用不到的非终结符**：从起始非终结符开始推导到的所有非终结符。其他的去掉。

造非终结符β，所有空规则的左部和能规约到的非终结符，删除空规则和**只能**导出空串的非终结符，扩充新规则，A=》xByD，变成：A=>xyD|xBy|xy|xByD。

消除左递归：S=》Sa|b,  S=>bS',S'=>aS'|ε。

### 6.文法分类

0型：图灵机，只要左部不为空。

1型：**自然语言**，上下文有关文法，**xUy** **::=** **xuy** ，**规则的左右部前缀和后缀对应相同**。不允许空规则。

2型：下推自动机，上下文无关文法，左部为单个非终结符。

3型：有穷自动机，正则文法，**左部是单个非终结符**，**要么均是右线性产生式，要么都是左线性产生式**。

## 三、自动机

确定有穷自动机（DFA）、不确定有穷自动机（NFA）

不确定是指读入符号后可以得到多个后继状态，即某个结点输出的不同边上有相同的符号。

（确定化）DFA转NFA。

最小化。

## 四、自顶向下分析文法

### 1. First集、Follow集

Select集：select(A->b) = {First(b)，当b不为空 | Follw(A)，other}

求Follow集：

- S为开始符号，把#加入到Follow(S)
- 若X->$\alpha​$B$\beta​$，把first($\beta​$)加入到Follow(B)
- 若X->$\alpha$B$\beta$，$\beta$广义推导到空，把Follow(X)加入到Follow(B)

### 2. 文法适用条件

非终结符多个候选式首个符号相同：提取左公因子。

文法具有左递归：消除左递归。

## 五、自底向上分析文法

### 1.算符优先分析法

#### 适用条件

- 一个上下无关文法，如果没有空规则，也没有两个非终结符。
- 任何终结符之间要么没有关系，要么关系唯一。

#### 算符优先矩阵构造

FIRSTVT集：若有产生式**P->a...或P->Qa...,则a∈FIRSTVT(P),若有产生式P->R...,则FIRSTVT(R)包含在FIRSTVT(P)中

LASTVT集：若有产生式P->...a或P->...aQ,则a∈LASTVT(P)若有产生式P->...R,则LASTVT(R)包含在LASTVT(P)中。

若有A->aB，则a < FIRSTVT(B)；

若有A-Ba，则LASTVT(B)>a；

素短语：至少含有一个终结符,且除自身外,不再包含任何其它更小的素短语。

最左素短语：是指位于句型最左边的那个素短语。

#### 优先函数

- 对于所有的运算符，令f(x)= g(x)=1；

- 若x＞y，且f(x)≤g(y)，则f(x)=g(y)+1；
- 若x＜y，且f(x)≥g(y)，则g(y)=f(x)+1；
- 若x=y，且f(x)≠g(y)，      则f(x)=g(y)=max（f(x)，g(y)；
- 重复，直到各优先数不再改变为止。

### 2.LR(0)分析文法

活前缀：包含可归约串，后一个是终结符。

可归前缀：句柄结尾的活前缀。



#### LR(0)分析表的构造

- 对于A→α△Xβ∈Si,GO(Si,X)=Sj,

​	   若X∈Vt,(移进项目)则置action[Si,X]=Sj

​	   若X∈Vn,(待约项目)则置goto[Si,X]=j

- 对于A→α△∈Si(归约项目),若A→α是
     文法的第j个产生式,则对所有的x∈Vt
     均置action[Si,x]=rj
- 若S→α△∈Si,则置action[Si,#]=acc
     （S为开始符号，接受项目）
- 其它情况均置出错

### 3. SLR(1)分析文法

#### 思想

SLR（1）方法是一种简单的LR（1）方法，它只能在不确定状态下向前看一个符号来解决冲突动作。

#### 适用条件

归约项目A→α△，C→α△，分别求Follow(A)和Follow(C)。

移进项目B→α△`b`，求其First(b)。

若Follow(A)∩Follow(C) ∩First(b)=Ø，则可以用SLR(1)方法来分析

#### 构造分析表

- 对于A→α△X∈Si，GO(Si,X)=Sj，

  若X∈Vt，(移进项目)则置action[Si,X]=Sj
  若X∈Vn，(待约项目)则置 goto[Si,X]=j

- 对于A→α△∈Si(归约项目)，若A→α是文法的
     第j个产生式,则对任何输入符号x∈Follow（A）
     则置action[Si,x]=rj 
- 若S→α△∈Si，则置action[Si,#]=acc
     （S为开始符号，接受项目）
- 其它情况均置出错

### 4. LR（1）分析文法

#### 求状态序列

初态：closure({[S’→ △ S，#]}) ;

Si的所有LR（1）项目∈CLOSURE(Si)

若[A→$\alpha$△X$\beta$，a]∈CLOSURE(Si)，X∈Vn
       则[X→△$\eta$，b]∈CLOSURE(Si) 
           b∈First($\eta$a)， a已知

#### 适用条件

如果是规约-移进冲突，当冲突的规约项目的展望集不包括移进项目后继符号时可以消除冲突

如果是规约-规约冲突，当两个归约项目的展望集不相交时，可以消除冲突。

#### LR（1）分析表的构造

- 对于[A→△X,a]∈Si,GO(Si,X)=Sj,
     若X∈Vt,(移进项目)则置action[Si,X]=Sj
     若X∈Vn,(待约项目)则置goto[Si,X]=j
- 对于[A→△,a]∈Si(归约项目),若A→是
     文法的第j个产生式,则置action[Si, a]=rj   
- 若[S→△,#]∈Si,则置action[Si,#]=acc
     （S为开始符号，归约项目）
- 其它情况均置出错



### 5. 分析文法的比较

![1561342182180](C:\Users\kolo\AppData\Roaming\Typora\typora-user-images\1561342182180.png)



## 八、语法制导翻译和中间代码生成

### 1. 属性文法

**综合属性**：**如果一个结点的某一属性值是由该结点的子结点的属性值计算来的**。

**继承属性**：**若一个结点的某一属性值是由该结点的兄弟结点和（或）父结点的属性值计算来的**。

### 2. 语法制导翻译

配合LR文法分析的语法制导翻译

| **步骤** | **状态栈** | **语义栈**     | **符号栈**          | **剩余输入串** | **Action**  | **GOTO** |
| -------- | ---------- | -------------- | ------------------- | -------------- | ----------- | -------- |
| **0**    | **0**      | **-**          | **#**               | **2＋3\*5＃**  | **S** **3** |          |
| **1**    | **03**     | **- -**        | **#2**              | **＋3\*5＃**   | **r** **5** | **2**    |
| **2**    | **02**     | **-2**         | **#** **T**         | **＋3\*5＃**   | **r** **3** | **1**    |
| **3**    | **01**     | **-2**         | **#** **E**         | **＋3\*5＃**   | **S** **4** |          |
| **4**    | **014**    | **-2-**        | **#** **E+**        | **3\*5＃**     | **S** **3** |          |
| **5**    | **0143**   | **-2- -**      | **#** **E+3**       | ***5＃**       | **r** **5** | **7**    |
| **6**    | **0147**   | **-2-3**       | **#E+T**            | ***5＃**       | **S** **5** |          |
| **7**    | **01475**  | **-2-3-**      | **#** **E+T**       | **5＃**        | **S** **6** |          |
| **8**    | **014756** | **- 2-3-5**    | **#** **E+T** **5** | **＃**         | **r** **4** | **7**    |
| **9**    | **0147**   | **-2-** **15** | **#** **E+T**       | **#**          | **r** **2** | **1**    |
| **10**   | **01**     | **-** **17**   | **#E**              | **#**          | **acc**     |          |

### 3.中间代码生成

中间代码生成的目的：便于代码的优化和便于目标程序的移植。

**逆波兰式**：运算对象写在前面，把运算符写在后面。

**三元式**：**(算符op，第一个运算对象ARG1,第二个运算对象ARG2)**。

**四元式**：**(算符，ARG1，ARG2，运算结果result)**。

四元式可以写成简单复制形式，（*，b，c，t） =>  t = b\*c 。

### 4.布尔表达式的翻译

布尔表达式有直接计算和短路计算两种分别。

对于逻辑表达式A or B and not C翻译成：

（not，C，-，t1）

（and，B，t1，t2）

（or，A，t2，t3）

对于关系表达式a<b可以翻译成为：if a<b then 1 else 0；

  (1) (  j<,  a,  b,  (4))

  (2) (  :=,  0,  - ,  t1)

  (3) (  jump,    - ,  - ,  (5))

  (4) (  :=,  1,  - ,  t1)

  (5)...



举例：  a<b or c < d and e > f 

|                   |                     |
| ----------------- | ------------------- |
| (1) (j<,a,b,(4))  | (8)(:=,0,-,t2)      |
| (2)(:=,0,-,t1)    | (9)(j>,e,f,(12))    |
| (3)(jump,-,-,(5)) | (10)(:=,1,-,t3)     |
| (4)(:=,1,-,t1)    | (11)(jump,-,-,(13)) |
| (5)(j<,c,d,(8))   | (12)(:=,0,-,t3)     |
| (6)(:=,1,-,t2)    | (13)(and,,t2,t3,t4) |
| (7)(jump,-,-,(9)) | (14)(or,t1,t4,t5)   |

拉链和回填：**在把布尔式翻译成一串条件转和无条件转四元式时，真假出口未能在生成四元式时确定；而且多个四元式可能有相同的出口**。



## 十一、代码优化

### 1. 优化技术

**优化阶段：**中间代码优化、目标代码优化。

**代码优化分类**：局部优化、循环优化、全局优化。

**中间代码优化：**

- **删除多余运算**
- **合并已知量与复写传播**
- **删除无用赋值**

其他优化技术：代码外提、强度削弱、变换循环控制条件。

### 2. 局部优化

#### 基本块

局部优化是指基本块内的优化。

基本块是只有一个入口一个出口。

基本块入口语句：程序第一个语句、条件转移语句或者无条件转移语句的转移目标语句、紧跟条件转移语句后面的语句 。

基本块出口：到下一个入口语句但不包括该语句、转移语句、停止语句。

#### 基本块DAG

基本块DAG：**常用来表示一个基本块。**

四元式的运算结果作根节点，两个操作数作子节点，运算符写在边上。

四元式分类：0，1，2，3型四元式。

**DAG对基本块优化的基本思想：** **首先顺序对基本块内的所有四元式构造成一个DAG，接着按构造结点的次序将DAG还原成四元式序列。则还原后四元式序列就是优化的基本块。**

例题：

**E=C+D**

**B=E**

**A=C+D+1+5**

**B=A+2**

DAG优化一下。

![1561172670732](C:\Users\kolo\AppData\Roaming\Typora\typora-user-images\1561172670732.png)

**E=C+D**

**A=E+6**

**B=A+2**

### 3.循环优化

代码外提：**把循环不变运算，即其结果独立于循环执行次数的表达式，提到循环的前面**。

循环不变运算：**运算量为常量或在循环外定值，每次循环时其值不变的运算。**

**强度削弱**：**强度削弱是指把程序中强度大的运算替换成强度小的运算。例如把乘法运算换成加法运算等**

**变换循环控制条件**：

