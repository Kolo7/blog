# UNIX的IO模型

### 五种IO模型

- blocking IO：阻塞式IO

- nonblocking IO：非阻塞式IO

- IO multiplexing：多路复用IO

- signal driven IO：信号驱动IO

- asynchronous IO：异步IO

#### 阻塞式I/O

默认情况下所有套接字的模型。

用户通过系统调用发起IO请求（recvfrom），内核等待直到数据报传输过来，将数据包复制到用户空间，系统调用返回成功。

**阻塞**:在内核等待的时候，只有数据报准备好或者是发生错误，例如信号中断，才会返回执行用户进程，该过程中都是被阻塞的。

#### 非阻塞式I/O

将套接字设置为非阻塞式就是在通知内核：当所请求的I/O操作一定要把该用户进程投入到睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。

**轮询**：用户将会多次的发起系统调用（revfrom），查看数据报是否准备好，如果没有，返回错误，否则复制数据报到用户空间，并且返回成功。这个过程称为轮询。

#### 多路复用I/O

调用select或者是poll，这两个系统调用可以为多个套接字发起真正的I/O系统调用，同时等待多个套接字的数据报，当任意一个数据报准备好时，返回可读条件。应用进程再发起recfrom系统调用复制可用的数据报。与阻塞式不同点在于，应用进程阻塞于select或是poll系统调用而非真正的I/O系统调用。

**复用**：select或是poll系统调用可以传入多个描述符，同时等待，任意描述符对应的数据报准备完毕，马上返回，结束阻塞。

#### 信号驱动式I/O

开启套接字信号驱动式I/O功能，通过sigaction系统调用安装一个信号驱动处理函数。该系统调用立即返回，应用进程继续工作。当数据报准备好时，内核为应用进程产生SIGIO信号。可以在信号处理函数中调用或是在主循环中发起recvfrom系统调用。只有在数据报复制的时候才阻塞应用进程。

#### 异步I/O

告知内核启动某个操作，让内核在整个操作完成之后通知我们。应用进程在这个过程中只需要调用系统调用，无需任何阻塞，实现真正的异步。

**异步**：和信号驱动式不同点是内核告诉我们的不是何时启动I/O操作，而是告诉我们，I/O操作何时完成，因为整合操作包括将数据报复制到应用空间都被内核完成了。





