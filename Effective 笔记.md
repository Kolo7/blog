# Effective C++ 读书笔记

本书以条款的方式为读者提供高效的建议，能够避免重复C++中常见坑点。记录一下条款和一些高效建议。

### 条款 01：视C++为一个联邦

在书中描述说，C++可以称为多重范型编程语言。包括过程形式、面向对象形式、函数式、泛型式、元编程。对于过程式、面向对象式、函数式、泛型式很好理解、元编程不太懂。但c++确实是一种不完全面向对象的语言。分成的次语言来说有：

- C。没有异常处理，没有对象。

- Object-Oriented C++。包括了面向对象的古典法则：封装继承多态。

- Template C。泛型编程在C++中的实践。

- STL。这个在我看来是不是太夸大。在我看来的亮点是，将对象编程带来的便利表现得跟函数编程一样。  

这个准则告诉我们在c++语言内部，最佳实践未必适用于所有方面。这点也反映出C++的弱点，限制太宽泛自由导致不容易达到高效。

### 条款 02：尽量用`const`,`enum`,`inline`替换`#define`

这一条准则就像是表面意思，`#define`定义的内容在预处理阶段进行，不可靠性太大。这完全是由于`#define`字符串替换的本质决定的。

`const`,`enum`替换掉你想要使用定义常量的地方，而`inline`和`template`的配合使用完美替代`#define`定义函数的功能。这让发生在预处理阶段的不可控事情，回到编译期间或者是运行期间，即使是发生错误也更加容易发现和处理。

### 条款 03：尽可能的使用`const`

`const`这个关键字可以限制的东西非常多。举个例：

```c++
const int a = 1;	//
const int *p = &a;	//
int * const p = &a;	//
void fun1(const int &param1){
	...
}

const int & fun2(){
	...
	return const_value;
}

class C{
public:
	const int method1(const &param1, const &param2)const{
		...
	}
private:
	const int field;
}

```

&emsp;&emsp;主要就是定义常量、指向常量的指针、是常量的指针、返回常量的函数、保证不改变非静态成员的成员函数。

&emsp;&emsp;这里在介绍`const`成员函数的时候，介绍到了两个流行概念：`bitwise constness`和`logical constness`。

&emsp;&emsp;前者对`const`成员函数是严格要求，必须不能改变任何成员变量。而默认的c++就是支持这样的概念，但想想指针和引用的问题，就算是改变了指向内容，而从对象的成员来看，也是什么都没改变，这样的保证也不是绝对管用的。

&emsp;&emsp;后者则宽松很多，`mutable`关键字标记成员变量后，该成员变量在`const`成员函数中发生改变是不会报错的。

&emsp;&emsp;文中介绍了一种重载，也就是`const`和`not-const`同名同参成员函数重载，通过`static_cast`和`const_cast`可以实现两个，函数之间进行互相调用，解决一些很不常见的问题（在我看来）。

- 本条款就是要多多利用`const`的限制，利用编译器来帮助检查，而不是程序员自己检查。
- 编译器强制使用`bitwise-constness`原则，但是可以使用`mutable`来突破。

- `const`和`not-const`有着相同实践的使用，利用转型来节省代码（`no-const`调用`const`）。  

### 条框 04：确定对象使用前已经被初始化

&emsp;&emsp;条框真的很直白，唯一值得学习的就是什么样的初始化是最佳实践？

&emsp;&emsp;对于普通内置类型，没什么特别，直接在定义的时候初始化是比较稳妥的。

&emsp;&emsp;对于类中的成员变量，在构造函数中初始化不是很好的事情，这样的操作更应该称为赋值。先是调用了成员的拷贝函数（内置对象不需要），然后又调用成员的赋值operator函数。

&emsp;&emsp;应该使用初始化列表，效率更高。所有的待初始化成员变量只有一次拷贝构造函数被调用（内置对象不需要）。哪怕是default构造函数，也可以使用初始化列表，只要不传参（调用成员的默认构造函数），故而在构造函数初始化列表中写入全部的成员变量是一个很好的规则（这真的很麻烦）。

&emsp;&emsp;初始化列表的好处还在于，常量成员是不可以在构造函数中赋值的，想要从传入参数赋值只能依赖初始化列表。

&emsp;&emsp;最好以成员变量的声明次序来书写初始化列表。避免一些特殊的错误，例如：初始化一个数组，但是其指定大小的成员变量还未初始化。

&emsp;&emsp;如果是多模块编程，并且当前源文件中有使用到其他的文件中定义的全局变量或者类静态成员，会出现使用变量时尚未定义的错误，这是因为c++的编译器不保证所有的源文件编译的次序。最好的方法是使用单例模式，也就是不使用类静态成员。

### 条款 05：了解c++编译器自动生成并调用什么函数

&emsp;&emsp;这个确实是c++编译器自定义的行为，对于一个空类，也就是你什么都不声明，编译器将自动生成下列函数：

- 默认构造函数 
- 拷贝构造函数
- operator=操作符
- 析构函数

&emsp;&emsp;编译器实现这些函数有一些规则：

- 默认的这些都是public和inline的。

- 只要书写任意的构造函数，编译器就将不会生成默认构造函数。
- 编译器产生的析构函数是非virtual，除非基类的析构函数是virtual。
- 如果没有调用这些默认实现方法的地方，默认实现函数将不会被实现，也就是延时实现。
- 还有一条规则就是如果类包含引用类型或者是const变量，将不会生成默认赋值函数，还包括了父类将自己的operator=定义为private的行为，也不会生成默认赋值函数。

### 条款 06：如果不想使用编译器提供默认函数，需要明确拒绝

&emsp;&emsp;前面说的编译器实现默认函数。如果某个函数不希望有默认实现，也不想要函数在其他地方被调用。那么可以使用private加上空实现的方法（这也是java中常干的事情）。

&emsp;&emsp;既是声明了private，c++中也有友元函数和成员函数可以调用，所以还有个更好的办法：在基类中将你不想要有默认实现的函数定义为private，派生类继承之后就可以了。这样子会有一点点问题，那就是多重继承问题，文中并没有讨论太多所以也可以暂时忽略了。

### 条款 07：为多态基类声明virtual析构函数

c++中如果一个基类和它的派生类正在搞动态绑定，在释放内存调用析构函数的时候会出问题，因为析构函数并不会遵从动态绑定，什么引用或指针就会调用对应的析构函数（为什么设计如此不明白），导致的后果是内存释放不完全，会出现不明确行为。为基类的析构函数标记一个virtual关键字，就可以解决的了，在运行时就会自动调用实际对象的析构函数。

- 一个需要有多态性质的基类，应该要有一个virtual析构函数。
- 一个带有virtual函数的类，应该要有一个virtual析构函数。
- 一个类如果不是作为基类的任务，或者没有多态的必要性，那么也没有必要声明virtual析构函数。

### 条款 08：别让析构函数抛出异常

析构函数抛出的异常没有什么地方能被程序捕获，因此是无意义的行为，会导致不明确结果。所以解决办法就是不抛出异常（吞了，或者over）。

- 析构函数中绝对不要抛出异常，要么在析构函数中捕获，要么直接结束程序。
- 如果析构函数中可能存在某种操作抛出异常，那么应该提供一个普通函数能够提前处理，以捕获异常。

### 条款 09：绝不在构造和析构过程中调用virtual函数

这个条款遵循起来没什么难度，所以重点就是为什么不要调用呢？

&emsp;&emsp;在java中使用的动态绑定的时候我没有考虑到这个问题，但是在c++中存在的是：一个派生类被构造之前，先构造其基类，在这个阶段，是不能够调用派生类的任何函数的，因此在基类的构造中想要调用被派生类重写的virtual函数是不会达到你的预期的。析构函数的调用层次顺序是和构造函数反着的，先是析构派生类部分，再是基类的析构函数，因此在基类的析构函数中，派生类其实已经不存在了，当前类退化成为了一个基类对象。派生类的任何virtual重写都是不起作用的。

&emsp;&emsp;我们需要做的就是在构造函数和析构函数中不要调用virtual函数，包括间接的方式。这样做不会达到我们的目的。

&emsp;&emsp;书中所推荐一种取代方法是利用派生类的构造传递必要的信息给基类，将信息向上传递交给基类处理。我还想到一种代替就干脆不要在构造和析构过程中利用动态绑定，要么之后，要么之前，手动的去调用。

### 条款 10：令operator=返回*this的引用

书上都非常的简短，就是那么浅显，除了operator=还有+=、-=等等。

### 条款 11：在operator=中处理“自我赋值”。

书中operator=函数中先删除了原来的值，再copy传入值，当传入值和自己是相同的时候，就GG了，因为copy一个已经删除的值，自然不会是我们预期的结果。

&emsp;&emsp;解决方法有多种，可以通过语句顺序的调整，先拷贝，再删除原值，也就是先CAS。还可以在形式参数下手，变成by value传递，这样做减少了代码清晰度，但是把优化的机会交给了编译器。

### 条款 12：复制对象勿忘任何一个成分

内容比较简单，也很容易接受，无这里的复制对象函数特指拷贝构造函数和operator=函数。对于少复制了部分，编译器不会报错提醒故而要注意，在派生类的拷贝构造函数中，一定要手动的调用基类的拷贝构造函数，并且将形参派生类传入，具体的工作交给基类去做。也不要试着在拷贝构造函数中调用operator=函数，或者反着来，这样会出现错误，最佳的做法是，都调用一个init成员函数。

### 条款 13：以对象管理资源

众所皆知，c++没有哦自动回收垃圾处理机制，在heap堆中new出来的对象，需要手动调用delete函数来清除占用内存和资源。但是，手动调用delete函数总会有失误的，精心设计也无法保证调用一定能够做到。故而要用特殊的对象来管理资源，将会在特定的情形自动的调用被管理对象的析构函数。

&emsp;&emsp;首先是类指针对象`std::auto_ptr`，使用方法如下：

```c++
std::auto_ptr<ClassName> pclazz(new CalssName());
```

&emsp;&emsp;这样得到`pclazz`在本函数作用域结束的时候就会销毁，也会调用其管理的对象。需要注意的是如果一个对象被多个`std::auto_ptr`指针对象管理，那么就会在退出作用域的时候多次调用被管理对象的析构函数，产生不可预测的结果。所以通过拷贝构造函数和=是不可以复制`auto_ptr`指针对象的，得到的效果是转移资源的拥有权，原来的`auto_ptr`将会变成null。

&emsp;&emsp;这个指针对象无法复制的特性导致它在很多的STL中无法使用，因为很多的容器要求元素具有复制的能力。

&emsp;&emsp;其次是很熟悉的一个垃圾处理机制，引用计数，在c++中体现是引用计数指针`std::tr1::shared_ptr`，使用如下：

```c++
std::tr1::shared_ptr<ClassName> pclazz(new ClassName());
```

缺点一如既往，无法解决循环引用问题。但是比前者要优秀的多。

### 条款 14：在资源管理类中注意copy行为

首先问题的来源是因为被管理的资源需要的copy是不一样的，最常见的有：禁止copy、copy只是多出一个引用、深度copy、转移资源拥有权等等。

- 禁止copy

  前面已经介绍过了，将copy的函数手动声明为private，或是继承`uncopyable`基类。

- copy引用

  这种也好理解，使用`std::tr1::shard_ptr`指针对象就可以达到目的，该指针的构造参数有第二个：`deleter`。这样的效果就是在指针对象消亡的时候，自动调用一次该`deleter`函数。

- 深度copy

  这样的copy，除了复制资源管理指针对象，还要复制管理的资源。具体实现需要实际情况来取决。

- 转移底部资源的拥有权

  表面意思，copy之后，原资源管理指针对象就为null。正是`std::auto_ptr`的特性。

总之，被管理资源的copy行为取决了`RAII`的copy行为。

### 条款 15：在资源管理类中提供对原始资源的访问

很多APIs要求访问原始资源，故而所有的RAII class也就是资源管理类都提供了对原始资源的访问方法，分为显示转换和隐式转换：

- 显式

  `std::auto_ptr.get()`get函数直接取得，还可以通过操作符`->`和`*`。

- 隐式

  这里介绍一种操作符函数：

  ```c++
  class AHandle {
  
  };
  class A {
  public:
      explicit A(AHandle f):f(f) {}
      operator AHandle() const {return this->f;}
  private:
      AHandle f;
  };
  void changeAHandle(AHandle f) { return; }
  int main()
  {
      AHandle f;
      A a(f);
      changeAHandle(a);
      return 0;
  }
  ```

  &emsp;&emsp;在设计上是有很大问题的，破坏了封装性，但是只是为了展示了一个小技巧。上面的理解起来应该毫无问题，A类有一个成员变量，类型为`AHandle`那么`operator AHandle()`函数就是在需要隐式转换时调用的函数。

### 条款 16：成对的使用new和delete时要采用相同的形式

提供了一种建议，如果是new的一个数组，那么delete的时候也要删除一个数组，如果没有做到，将会产生不可预知的错误，很严重。还有就是不要用typedef去改变一个数组的名字。

### 条款 17：以独立语句将new创建的对象赋值给智能指针

c++在一条语句内如果有多个操作，执行的顺序可能不会有保障。为了避免创建出来的对象在赋值给指针管理的过程中出现异常，导致对象失去管理从而内存泄漏，需要将初始化语句单独列出来。

```c++
// 如果在priority()中出现异常，那么赋值指针的操作可能就不会执行。
processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority());  // 错误语句

// 改为这样
std::tr1::shared_ptr<Widget> ptr(new Widget);
processWidget(ptr, priority());
```

### 条款 18：让接口容易被正确使用，不容易误用

这可以运用面向对象的设计，还有各种设计模式，总之事关设计而非什么c++的独特性质。

### 条款 19：设计class

书中这章发起了很多提问，总结起来，c++设计一个类我们需要关心一些问题：对象的创建和销毁，对象的初始化和赋值，对象的拷贝构造函数、类中成员的合法值，继承问题，是否需要显式转换和隐式转换，操作符，禁止默认实现函数，成员的访问域，回想自己是否需要定义一个类。

### 条款 20：用引用传递取代值传递

原因很简单，值传递需要拷贝，引用传递不需要，更加高效；值传递在动态绑定时，出现切割问题，无法做到动态绑定。值传递，哪怕是很小的对象可能也会采用不是那么高效的运行方式。

内置类型和STL的迭代器和函数采用值传递是比较合适的。

### 条款 21：函数需要返回对象时，不要返回其引用

这个我亲身实践过，一个局部对象的引用是无意义的，绝对报错。也不要返回一个堆内对象，因为找不到合适的机会delete，最好就是返回值，编译器会为这个过程做优化的，不一定有构造和赋值过程，所以代价是可以接受的。

### 条款 22：成员变量声明为private

显而易见，这已经是面向对象编程的一种良好习惯了。

### 条款 23：用非成员函数取代成员函数

这一条建议有点高深莫测，书中指出，非成员函数降低了类的整合度，但是提高了类的封装性，需要注意的一点，书中还说：成为一个类的非成员函数并不意味着它不可以是别的类的成员函数。学过java的心里好受多了。这也意味着，使用一个类，增加其封装性性能，最好的办法可能是为其创建工具类？这很难琢磨。在c++中有namespace的概念，这可能也是这条准则适用的一个原因。

### 条款 24：如果所有的参数都需要类型转换，请使用no-member函数

书中举的例子是一个类的operator*函数，如果是非成员函数的话，可以避免参数交换位置的问题。算是一个经验性的规则吧。还提到不应该声明为友元函数，主要原因还是因为友元函数对封装性有不小的破坏。

### 条款 25：考虑写一个不抛出异常的swap函数

直接摘抄书中建议：

- 当`std::swap`的效率不能够满足的时候，提供一个swap成员函数，并且确定这个函数不会抛出异常。
- 提供一个非成员函数去调用前者。对于class（而不是class Template）请特化`std::swap`。
- 调用swap的时候，使用`std:swap`的using声明式，然后调用swap函数，不要带任何的命名空间修饰符，将选择权交给编译器。
- 为用户定义类型进行class template全特化是可以的，但是不能加入到std空间中。

### 条款 26：尽可能延后变量定义式的出现时间

这个建议很容易理解，不必要的变量定义甚至会被编译器自动忽略掉。

### 条款27：尽量少转型

先介绍一下转型的方式：

-  C风格转型`(T)expreesion`

- 函数风格转型`T(expreesion)`

- 新形式

  - const_cast<T>(expreesion)

    可以移除常量性。

  - dynamic_cast<T>(expreesion)

    执行安全向下转型，唯一无法由上两种转型方法做到的。

  - reinterpret_cast<T>(expreesion)

  ​		执行低级转型，针对内存。使用要慎重，不具有移植性。

  - static_cast<T>(expreesion)

    将原来的隐式转换显式化。其实就是目标的对应参数构造函数。

当代码需要强制转型，就需要好好想想面向对象的思想是不是用的不够，父类有多少必要性需要转型为子类。

### 条款 28：避免返回对象内部的私有成员对象

这个建议对java程序员来说是不容易违反的，返回一个这样的成员对象，总让我心里发毛。这意味着封装性的破坏，而且我们总有替代方法来取代这样做，还能做的更好。

### 条款 29：异常安全性

书中的比喻太恰当了，异常安全性就像是怀孕，只有怀孕和没怀孕，不存在局部怀孕。

异常安全函数提供下面三个保障之一：

- 基本承诺：如果异常被抛出，程序的任何事物仍然保持在有效状态下。这种保证比较弱，他只是保证代码还能继续跑下去，但是对于正确逻辑不做保证了。
- 强烈保证：如果异常抛出，程序的状态不改变。这样的保障要比上面的强，调用这样的函数，要么成功继续，要么失败返回调用函数之前的状态。
- 不抛出保证：承诺绝对不抛出异常，这是最高等级，但是不是任何的函数都能做这样的保证。只要涉及资源，例如内存申请释放，锁的占有和解放，就无法保障这个。

强烈保证往往能够通过CAS实现，但是强烈保证并非对所有的函数都有可实现的意义。

函数提供的异常安全性通常等于其调用函数的异常安全性最低者。

