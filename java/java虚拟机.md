# java虚拟机

### 1. 内存管理

#### 运行时数据区域

区域 | 是否线程私有 | 描述
---|---|---
程序记数器 | 是 | 指示线程执行的字节码位置 
java虚拟机栈 | 是 | 栈帧保存局部变量表、操作栈、动态链接、方法出口
本地方法栈 | 是 | 和java虚拟机栈类似，配合的是Native方法
java堆 | 否 | 对象实例存放区域
方法区 | 否 |   保存类信息、常量、静态变量

#### 对象创建流程

1. 在常量池查找有无对应符号引用，并且检查引用类是否类加载过，没有则加载类。
2. 在java堆中分配内存。  
3. 初始化内存空间。
4. 设置对象，元数据信息、hash码、GC分代年龄。
5. <init>方法执行，完成对象初始化。

##### 堆溢出
创建大量对象，并且保持引用。

##### 栈溢出
重复递归调用方法。

### 2. 垃圾收集器和内存分配策略

#### 确认对象存活

1. 引用计数法  
每有一个引用指向一个对象，就为该对象的引用计数加一。当对象的引用数为零的时候，代表对象不可能再被使用。
2. 可达性分析算法  
    从GC Roots向下搜索所有引用，若某个对象从GC Roots不可达，则证明对象不可用。  
    GC Roots：虚拟机栈中的引用对象、方法区中类的静态属性、方法区中类的常量、本地方法栈中JNI引用对象。

#### finalize()方法

当对象被垃圾回收器第一次标记的时候，会检查对象是否有必要执行finalize()方法，也就是覆盖了finalize()，且没有执行过finalize()方法。有必要执行方法的对象放入F-Queue队列，在稍后会执行队列中所有对象的finalize()方法，并且会第二次对队列中的对象进行垃圾回收，如果在finalize()方法中成功将自己的引用和某个对象产生关联，就可以摆脱垃圾回收。  

#### 方法区回收

主要回收无用的常量、类。  
无用的常量：没有任何地方引用该常量。  
无用的类：不存在类对应的实例、加载该类的ClassLoader被回收、该类对应的java.lang.Class对象没有在任何地方被引用。 

#### 引用类型

- 强引用是指在代码中普遍存在的。只要强引用还存在，垃圾回收器永远不会回收掉引用的对象。  

- 软引用是用来描述一些还有用但并非是必要的对象。对于软引用着的对象，在系统将要发生内存溢出异常之前，将会把这类对象列进回收范围进行第二次的回收。如果这次回收仍然没有足够的内存，就会抛出内存溢出异常。在 jdk1.2 中提供了 SoftReference 类来实现软引用  

- 被弱引用关联的对象只能生存到下一次的垃圾回收之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 jdk1.2 中提供了 WeakReference 类来实现弱引用  

- 虚引用也被称为幽灵引用或幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集时收到一个系统通知。在 jdk1.2 中提供了 PhantomReference 类来实现虚引用。

#### 垃圾回收算法

1. 标记-清除算法
    很实用的算法，但是会产生大量的碎片，并且效率不高。
2. 复制算法
    实现简单、运行高效。但是浪费一半的内存空间，并且需要分配担保。适合新生代。
3. 标记-整理算法
    标记和第一种算法一样，但是不清除，而是移动整理所有的存活对象。适合老年代。
4. 分代收集算法
    也就是根据新生代、老年代的特点选择不同的回收算法。一般新生代选用复制算法，老年代选用其他两种算法。  

#### 对象分配和回收策略

1. 新生代一般内存分为Eden空间和两块Surivor空间。jdk1.7中比例为8:1，jdk1.8中是6：1。这是为了使用算法，移动对象。一般对象在Eden空间分配。  
2. 大对象直接进入老年代。
3. 长期存活的对象将进入老年代。一般是年龄达到15岁的对象,也就是经历十五次Minor GC。
4. 动态对象年龄判定。如果在Surivor空间中相同年龄所有对象的大小总和超过了Surivor空间的一半大小，年龄大于或者等于该年龄的对象就可以直接进入老年代。
5. 空间分配担保
6. 在发生Minor GC之前，检查老年代最大可用连续空间是否大于新生代所有对象之和，大于则Minor GC，否则查看是否允许担保失败。如果允许担保失败，则继续检查老年代最大可用的连续空间是否大于历次晋升老年代对象的平均大小，如果大于则进行一次Minor GC；如果小于或者不允许担保失败，则进行一次Full GC。

### 3. 类加载机制
#### 类的生命周期

加载->验证->准备->解析->初始化->使用->卸载  
验证、准备、解析阶段统称为连接阶段。  

#### 类初始化的时机

1. 最常见的几种：new 一个对象，读取或设置一个类的静态字段，调用一个类的静态方法。
2. 进行类反射调用。
3. 初始化一个类，发现其父类还没有初始化。出发其父类的初始化。
4. 虚拟机启动，指定执行的主类（包含mian()方法的类），初始化该主类。
5. 动态语言支持中的特殊情况。

##### 初始化
类初始化是类加载的最后一步，也是真正开始执行类定义中代码的部分。其他的步骤暂不分析。  
- 准备阶段，类中变量被赋过一次初值，类初始化阶段，会整合类中所有类变量的赋值动作和静态语句块（static{}块），产生`<clinit>()`方法。  
- 虚拟机保证在执行子类的`<clinit>()`方法之前，一定执行父类的`<cliint>()`方法。
- 父类的静态语句块一定在子类的静态语句块之前执行。
- `<clinit>()`方法不是必须的，如果类和接口中没有静态语句块和对变量的赋值操作，那么不会生成`<clinit>()`方法。
- 接口中也有变量的赋值操作，所以也有`<clinit>()`方法。子接口`<clinit>()`不一定要在父接口`<clinit>()`执行之后。只有当父接口中定义的变量使用时，父接口才会初始化。
- 虚拟机保证`<clinit>()`在多线程下的安全性，并且多个线程中只有一个能执行`<clinit>()`方法一次。

#### 双亲委派模型

![双亲委派模型](https://img-blog.csdn.net/20180530145526542?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGVqYXM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
类加载器的双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的一种加载器方式。上面类加载器的父子关系一般不会以继承的方式实现，而是采用组合的关系来复用父类加载器的代码。  

工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器，只有当父加载器无法完成这个加载请求时，子加载器才会尝试自己去加载。  

为什么要有双亲委派模型呢？原因是双亲委派模型可以保证 Java 程序的稳定性。比如你有一个类，在不采用双亲委派模型的情况下，可能会有不同的加载器去加载这个类，不同类加载器加载出来的 Class 文件必然不相同，这样就造成了不一致性。

### java内存模型与线程

##### 内存模型
__主内存__：与硬件上的主内存不是同一定义，是虚拟机内存的一部分。所有的变量都存储在主内存中。线程不可以直接读写主存。  
__工作内存__：每条线程都有自己的工作内存，可以类比于每个cpu共享主存，但是都有自己的Cache。所有线程不可以互相访问工作内存。工作内存中的变量都是主存中的拷贝。线程读写都在工作内存中。  

##### 内存间交互操作
内存间的交互操作有八种，都是原子级、不可再分的（对于double和long类型有特例）。  
- lock：作用于主内存，线程独占变量。
- unlock：作用于主内存，释放线程独占。
- read：作用于主内存，把变量值从主内存中读取到工作内存中。  
- load：作用于工作内存，把read操作读取的变量放入到工作内存的副本中。
- use：作用于工作内存，把工作内存中一个变量的值传递给执行引擎。
- assign：作用于工作内存 ，从执行引擎中传递一个值给工作内存。
- store：作用于工作内存，把一个变量的值传递给主内存。
- write：作用于主内存，把从工作内存传递过来的变量值写入到主内存相应的变量中。

这八个基本操作需要遵循若干规定：  
- 不允许read和load、store和write单独出现。
- 不允许线程丢弃最近的assign操作。
- 不允许没有发生过assign操作直接把数据从工作内存回写到主内存中。
- 不允许在工作内存中使用未在主内存中初始化的变量。
- 一个变量在同一时刻只允许一个线程对其lock操作。但lock操作可以被同一线程多次lock，需要执行多次unlock才可以解锁。
- lock一个变量，将会清空工作内存中该变量的值。
- 线程没有对一个变量执行lock操作，就无法执行unlock操作。不允许对其他线程锁住的变量unlock操作。
- 对一个变量unlock之前，需要将变量回写到主内存中。

##### volatile变量的特殊规则
volatile变量的特性：  
1. 保证变量对所有线程的可见性。  
2. 禁止指令重排序优化。

但是这不能保证volatile变量的线程安全性。
为了满足volatile达到这些特性，需要对volatile变量在内存模型中有特殊规则：  
假定有线程T，V、W分别代表两个volatile变量。

- 在T线程中，V变量的read、load、use操作是相关联，必须连续出现。
- 在T线程中，assign、store、write操作是相关联的，必须连续出现。
- 假定动作A是线程T对变量V的use或者assign动作，F是和动作A关联的load或者store动作，动作P是和动作F相关联的变量V的read或者write动作；类似的，B是线程T对变量W的use或者assign动作，动作G是和动作B关联的load或者store动作，动作Q是和动作G相关联的变量W的read或者write动作。如果有A优先于B，那么P优于Q。

##### 原子性、可见性、有序性
volatile可以保证可见性和有序性。
synchronized保证原子性、可见性、有序性。 
final保证了可见性。 